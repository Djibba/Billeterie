'use strict';

const mquery = require('../');
const assert = require('assert');

describe('mquery', function() {
  let col;

  before(function(done) {
    // get the env specific collection interface
    require('./env').getCollection(function(err, collection) {
      assert.ifError(err);
      col = collection;
      done();
    });
  });

  after(function(done) {
    require('./env').dropCollection(done);
  });

  describe('mquery', function() {
    it('is a function', function() {
      assert.equal('function', typeof mquery);
    });
    it('creates instances with the `new` keyword', function() {
      assert.ok(mquery() instanceof mquery);
    });
    describe('defaults', function() {
      it('are set', function() {
        const m = mquery();
        assert.strictEqual(undefined, m.op);
        assert.deepEqual({}, m.options);
      });
    });
    describe('criteria', function() {
      it('if collection-like is used as collection', function() {
        const m = mquery(col);
        assert.equal(col, m._collection.collection);
      });
      it('non-collection-like is used as criteria', function() {
        const m = mquery({ works: true });
        assert.ok(!m._collection);
        assert.deepEqual({ works: true }, m._conditions);
      });
    });
    describe('options', function() {
      it('are merged when passed', function() {
        let m;
        m = mquery(col, { w: 'majority' });
        assert.deepEqual({ w: 'majority' }, m.options);
        m = mquery({ name: 'mquery' }, { w: 'majority' });
        assert.deepEqual({ w: 'majority' }, m.options);
      });
    });
  });

  describe('toConstructor', function() {
    it('creates subclasses of mquery', function() {
      const opts = { safe: { w: 'majority' }, readPreference: 'p' };
      const match = { name: 'test', count: { $gt: 101 } };
      const select = { name: 1, count: 0 };
      const update = { $set: { x: true } };
      const path = 'street';

      const q = mquery().setOptions(opts);
      q.where(match);
      q.select(select);
      q.updateOne(update);
      q.where(path);
      q.find();

      const M = q.toConstructor();
      const m = M();

      assert.ok(m instanceof mquery);
      assert.deepEqual(opts, m.options);
      assert.deepEqual(match, m._conditions);
      assert.deepEqual(select, m._fields);
      assert.deepEqual(update, m._update);
      assert.equal(path, m._path);
      assert.equal('find', m.op);
    });
  });

  describe('setOptions', function() {
    it('calls associated methods', function() {
      const m = mquery();
      assert.equal(m._collection, null);
      m.setOptions({ collection: col });
      assert.equal(m._collection.collection, col);
    });
    it('directly sets option when no method exists', function() {
      const m = mquery();
      assert.equal(m.options.woot, null);
      m.setOptions({ woot: 'yay' });
      assert.equal(m.options.woot, 'yay');
    });
    it('is chainable', function() {
      const m = mquery();
      let n;

      n = m.setOptions();
      assert.equal(m, n);
      n = m.setOptions({ x: 1 });
      assert.equal(m, n);
    });
  });

  describe('collection', function() {
    it('sets the _collection', function() {
      const m = mquery();
      m.collection(col);
      assert.equal(m._collection.collection, col);
    });
    it('is chainable', function() {
      const m = mquery();
      const n = m.collection(col);
      assert.equal(m, n);
    });
  });

  describe('$where', function() {
    it('sets the $where condition', function() {
      const m = mquery();
      function go() {}
      m.$where(go);
      assert.ok(go === m._conditions.$where);
    });
    it('is chainable', function() {
      const m = mquery();
      const n = m.$where('x');
      assert.equal(m, n);
    });
  });

  describe('where', function() {
    it('without arguments', function() {
      const m = mquery();
      m.where();
      assert.deepEqual({}, m._conditions);
    });
    it('with non-string/object argument', function() {
      const m = mquery();

      assert.throws(function() {
        m.where([]);
      }, /path must be a string or object/);
    });
    describe('with one argument', function() {
      it('that is an object', function() {
        const m = mquery();
        m.where({ name: 'flawed' });
        assert.strictEqual(m._conditions.name, 'flawed');
      });
      it('that is a query', function() {
        const m = mquery({ name: 'first' });
        const n = mquery({ name: 'changed' });
        m.where(n);
        assert.strictEqual(m._conditions.name, 'changed');
      });
      it('that is a string', function() {
        const m = mquery();
        m.where('name');
        assert.equal('name', m._path);
        assert.strictEqual(m._conditions.name, undefined);
      });
    });
    it('with two arguments', function() {
      const m = mquery();
      m.where('name', 'The Great Pumpkin');
      assert.equal('name', m._path);
      assert.strictEqual(m._conditions.name, 'The Great Pumpkin');
    });
    it('is chainable', function() {
      const m = mquery();

      let n = m.where('x', 'y');
      assert.equal(m, n);
      n = m.where();
      assert.equal(m, n);
    });
  });
  describe('equals', function() {
    it('must be called after where()', function() {
      const m = mquery();
      assert.throws(function() {
        m.equals();
      }, /must be used after where/);
    });
    it('sets value of path set with where()', function() {
      const m = mquery();
      m.where('age').equals(1000);
      assert.deepEqual({ age: 1000 }, m._conditions);
    });
    it('is chainable', function() {
      const m = mquery();
      const n = m.where('x').equals(3);
      assert.equal(m, n);
    });
  });
  describe('eq', function() {
    it('is alias of equals', function() {
      const m = mquery();
      m.where('age').eq(1000);
      assert.deepEqual({ age: 1000 }, m._conditions);
    });
  });
  describe('or', function() {
    it('pushes onto the internal $or condition', function() {
      const m = mquery();
      m.or({ 'Nightmare Before Christmas': true });
      assert.deepEqual([{ 'Nightmare Before Christmas': true }], m._conditions.$or);
    });
    it('allows passing arrays', function() {
      const m = mquery();
      const arg = [{ 'Nightmare Before Christmas': true }, { x: 1 }];
      m.or(arg);
      assert.deepEqual(arg, m._conditions.$or);
    });
    it('allows calling multiple times', function() {
      const m = mquery();
      const arg = [{ looper: true }, { x: 1 }];
      m.or(arg);
      m.or({ y: 1 });
      m.or([{ w: 'oo' }, { z: 'oo' }]);
      assert.deepEqual([{ looper: true }, { x: 1 }, { y: 1 }, { w: 'oo' }, { z: 'oo' }], m._conditions.$or);
    });
    it('is chainable', function() {
      const m = mquery();
      m.or({ o: 'k' }).where('name', 'table');
      assert.deepEqual({ name: 'table', $or: [{ o: 'k' }] }, m._conditions);
    });
  });

  describe('nor', function() {
    it('pushes onto the internal $nor condition', function() {
      const m = mquery();
      m.nor({ 'Nightmare Before Christmas': true });
      assert.deepEqual([{ 'Nightmare Before Christmas': true }], m._conditions.$nor);
    });
    it('allows passing arrays', function() {
      const m = mquery();
      const arg = [{ 'Nightmare Before Christmas': true }, { x: 1 }];
      m.nor(arg);
      assert.deepEqual(arg, m._conditions.$nor);
    });
    it('allows calling multiple times', function() {
      const m = mquery();
      const arg = [{ looper: true }, { x: 1 }];
      m.nor(arg);
      m.nor({ y: 1 });
      m.nor([{ w: 'oo' }, { z: 'oo' }]);
      assert.deepEqual([{ looper: true }, { x: 1 }, { y: 1 }, { w: 'oo' }, { z: 'oo' }], m._conditions.$nor);
    });
    it('is chainable', function() {
      const m = mquery();
      m.nor({ o: 'k' }).where('name', 'table');
      assert.deepEqual({ name: 'table', $nor: [{ o: 'k' }] }, m._conditions);
    });
  });

  describe('and', function() {
    it('pushes onto the internal $and condition', function() {
      const m = mquery();
      m.and({ 'Nightmare Before Christmas': true });
      assert.deepEqual([{ 'Nightmare Before Christmas': true }], m._conditions.$and);
    });
    it('allows passing arrays', function() {
      const m = mquery();
      const arg = [{ 'Nightmare Before Christmas': true }, { x: 1 }];
      m.and(arg);
      assert.deepEqual(arg, m._conditions.$and);
    });
    it('allows calling multiple times', function() {
      const m = mquery();
      const arg = [{ looper: true }, { x: 1 }];
      m.and(arg);
      m.and({ y: 1 });
      m.and([{ w: 'oo' }, { z: 'oo' }]);
      assert.deepEqual([{ looper: true }, { x: 1 }, { y: 1 }, { w: 'oo' }, { z: 'oo' }], m._conditions.$and);
    });
    it('is chainable', function() {
      const m = mquery();
      m.and({ o: 'k' }).where('name', 'table');
      assert.deepEqual({ name: 'table', $and: [{ o: 'k' }] }, m._conditions);
    });
  });

  function generalCondition(type) {
    return function() {
      it('accepts 2 args', function() {
        const m = mquery()[type]('count', 3);
        const check = {};
        check['$' + type] = 3;
        assert.deepEqual(m._conditions.count, check);
      });
      it('uses previously set `where` path if 1 arg passed', function() {
        const m = mquery().where('count')[type](3);
        const check = {};
        check['$' + type] = 3;
        assert.deepEqual(m._conditions.count, check);
      });
      it('throws if 1 arg was passed but no previous `where` was used', function() {
        assert.throws(function() {
          mquery()[type](3);
        }, /must be used after where/);
      });
      it('is chainable', function() {
        const m = mquery().where('count')[type](3).where('x', 8);
        const check = { x: 8, count: {} };
        check.count['$' + type] = 3;
        assert.deepEqual(m._conditions, check);
      });
      it('overwrites previous value', function() {
        const m = mquery().where('count')[type](3)[type](8);
        const check = {};
        check['$' + type] = 8;
        assert.deepEqual(m._conditions.count, check);
      });
    };
  }

  'gt gte lt lte ne in nin regex size maxDistance minDistance'.split(' ').forEach(function(type) {
    describe(type, generalCondition(type));
  });

  describe('mod', function() {
    describe('with 1 argument', function() {
      it('requires a previous where()', function() {
        assert.throws(function() {
          mquery().mod([30, 10]);
        }, /must be used after where/);
      });
      it('works', function() {
        const m = mquery().where('madmen').mod([10, 20]);
        assert.deepEqual(m._conditions, { madmen: { $mod: [10, 20] } });
      });
    });

    describe('with 2 arguments and second is non-Array', function() {
      it('requires a previous where()', function() {
        assert.throws(function() {
          mquery().mod('x', 10);
        }, /must be used after where/);
      });
      it('works', function() {
        const m = mquery().where('madmen').mod(10, 20);
        assert.deepEqual(m._conditions, { madmen: { $mod: [10, 20] } });
      });
    });

    it('with 2 arguments and second is an array', function() {
      const m = mquery().mod('madmen', [10, 20]);
      assert.deepEqual(m._conditions, { madmen: { $mod: [10, 20] } });
    });

    it('with 3 arguments', function() {
      const m = mquery().mod('madmen', 10, 20);
      assert.deepEqual(m._conditions, { madmen: { $mod: [10, 20] } });
    });

    it('is chainable', function() {
      const m = mquery().mod('madmen', 10, 20).where('x', 8);
      const check = { madmen: { $mod: [10, 20] }, x: 8 };
      assert.deepEqual(m._conditions, check);
    });
  });

  describe('exists', function() {
    it('with 0 args', function() {
      it('throws if not used after where()', function() {
        assert.throws(function() {
          mquery().exists();
        }, /must be used after where/);
      });
      it('works', function() {
        const m = mquery().where('name').exists();
        const check = { name: { $exists: true } };
        assert.deepEqual(m._conditions, check);
      });
    });

    describe('with 1 arg', function() {
      describe('that is boolean', function() {
        it('throws if not used after where()', function() {
          assert.throws(function() {
            mquery().exists();
          }, /must be used after where/);
        });
        it('works', function() {
          const m = mquery().exists('name', false);
          const check = { name: { $exists: false } };
          assert.deepEqual(m._conditions, check);
        });
      });
      describe('that is not boolean', function() {
        it('sets the value to `true`', function() {
          const m = mquery().where('name').exists('yummy');
          const check = { yummy: { $exists: true } };
          assert.deepEqual(m._conditions, check);
        });
      });
    });

    describe('with 2 args', function() {
      it('works', function() {
        const m = mquery().exists('yummy', false);
        const check = { yummy: { $exists: false } };
        assert.deepEqual(m._conditions, check);
      });
    });

    it('is chainable', function() {
      const m = mquery().where('name').exists().find({ x: 1 });
      const check = { name: { $exists: true }, x: 1 };
      assert.deepEqual(m._conditions, check);
    });
  });

  describe('elemMatch', function() {
    describe('with null/undefined first argument', function() {
      assert.throws(function() {
        mquery().elemMatch();
      }, /Invalid argument/);
      assert.throws(function() {
        mquery().elemMatch(null);
      }, /Invalid argument/);
      assert.doesNotThrow(function() {
        mquery().elemMatch('', {});
      });
    });

    describe('with 1 argument', function() {
      it('throws if not a function or object', function() {
        assert.throws(function() {
          mquery().elemMatch([]);
        }, /Invalid argument/);
      });

      describe('that is an object', function() {
        it('throws if no previous `where` was used', function() {
          assert.throws(function() {
            mquery().elemMatch({});
          }, /must be used after where/);
        });
        it('works', function() {
          const m = mquery().where('comment').elemMatch({ author: 'joe', votes: { $gte: 3 } });
          assert.deepEqual({ comment: { $elemMatch: { author: 'joe', votes: { $gte: 3 } } } }, m._conditions);
        });
      });
      describe('that is a function', function() {
        it('throws if no previous `where` was used', function() {
          assert.throws(function() {
            mquery().elemMatch(function() {});
          }, /must be used after where/);
        });
        it('works', function() {
          const m = mquery().where('comment').elemMatch(function(query) {
            query.where({ author: 'joe', votes: { $gte: 3 } });
          });
          assert.deepEqual({ comment: { $elemMatch: { author: 'joe', votes: { $gte: 3 } } } }, m._conditions);
        });
      });
    });

    describe('with 2 arguments', function() {
      describe('and the 2nd is an object', function() {
        it('works', function() {
          const m = mquery().elemMatch('comment', { author: 'joe', votes: { $gte: 3 } });
          assert.deepEqual({ comment: { $elemMatch: { author: 'joe', votes: { $gte: 3 } } } }, m._conditions);
        });
      });
      describe('and the 2nd is a function', function() {
        it('works', function() {
          const m = mquery().elemMatch('comment', function(query) {
            query.where({ author: 'joe', votes: { $gte: 3 } });
          });
          assert.deepEqual({ comment: { $elemMatch: { author: 'joe', votes: { $gte: 3 } } } }, m._conditions);
        });
      });
      it('and the 2nd is not a function or object', function() {
        assert.throws(function() {
          mquery().elemMatch('comment', []);
        }, /Invalid argument/);
      });
    });
  });

  describe('within', function() {
    it('is chainable', function() {
      const m = mquery();
      assert.equal(m.where('a').within(), m);
    });
    describe('when called with arguments', function() {
      it('must follow where()', function() {
        assert.throws(function() {
          mquery().within([]);
        }, /must be used after where/);
      });

      describe('of length 1', function() {
        it('throws if not a recognized shape', function() {
          assert.throws(function() {
            mquery().where('loc').within({});
          }, /Invalid argument/);
          assert.throws(function() {
            mquery().where('loc').within(null);
          }, /Invalid argument/);
        });
        it('delegates to circle when center exists', function() {
          const m = mquery().where('loc').within({ center: [10, 10], radius: 3 });
          assert.deepEqual({ $geoWithin: { $center: [[10, 10], 3] } }, m._conditions.loc);
        });
        it('delegates to box when exists', function() {
          const m = mquery().where('loc').within({ box: [[10, 10], [11, 14]] });
          assert.deepEqual({ $geoWithin: { $box: [[10, 10], [11, 14]] } }, m._conditions.loc);
        });
        it('delegates to polygon when exists', function() {
          const m = mquery().where('loc').within({ polygon: [[10, 10], [11, 14], [10, 9]] });
          assert.deepEqual({ $geoWithin: { $polygon: [[10, 10], [11, 14], [10, 9]] } }, m._conditions.loc);
        });
        it('delegates to geometry when exists', function() {
          const m = mquery().where('loc').within({ type: 'Polygon', coordinates: [[10, 10], [11, 14], [10, 9]] });
          assert.deepEqual({ $geoWithin: { $geometry: { type: 'Polygon', coordinates: [[10, 10], [11, 14], [10, 9]] } } }, m._conditions.loc);
        });
      });

      describe('of length 2', function() {
        it('delegates to box()', function() {
          const m = mquery().where('loc').within([1, 2], [2, 5]);
          assert.deepEqual(m._conditions.loc, { $geoWithin: { $box: [[1, 2], [2, 5]] } });
        });
      });

      describe('of length > 2', function() {
        it('delegates to polygon()', function() {
          const m = mquery().where('loc').within([1, 2], [2, 5], [2, 4], [1, 3]);
          assert.deepEqual(m._conditions.loc, { $geoWithin: { $polygon: [[1, 2], [2, 5], [2, 4], [1, 3]] } });
        });
      });
    });
  });

  describe('geoWithin', function() {
    before(function() {
      mquery.use$geoWithin = false;
    });
    after(function() {
      mquery.use$geoWithin = true;
    });
    describe('when called with arguments', function() {
      describe('of length 1', function() {
        it('delegates to circle when center exists', function() {
          const m = mquery().where('loc').within({ center: [10, 10], radius: 3 });
          assert.deepEqual({ $within: { $center: [[10, 10], 3] } }, m._conditions.loc);
        });
        it('delegates to box when exists', function() {
          const m = mquery().where('loc').within({ box: [[10, 10], [11, 14]] });
          assert.deepEqual({ $within: { $box: [[10, 10], [11, 14]] } }, m._conditions.loc);
        });
        it('delegates to polygon when exists', function() {
          const m = mquery().where('loc').within({ polygon: [[10, 10], [11, 14], [10, 9]] });
          assert.deepEqual({ $within: { $polygon: [[10, 10], [11, 14], [10, 9]] } }, m._conditions.loc);
        });
        it('delegates to geometry when exists', function() {
          const m = mquery().where('loc').within({ type: 'Polygon', coordinates: [[10, 10], [11, 14], [10, 9]] });
          assert.deepEqual({ $within: { $geometry: { type: 'Polygon', coordinates: [[10, 10], [11, 14], [10, 9]] } } }, m._conditions.loc);
        });
      });

      describe('of length 2', function() {
        it('delegates to box()', function() {
          const m = mquery().where('loc').within([1, 2], [2, 5]);
          assert.deepEqual(m._conditions.loc, { $within: { $box: [[1, 2], [2, 5]] } });
        });
      });

      describe('of length > 2', function() {
        it('delegates to polygon()', function() {
          const m = mquery().where('loc').within([1, 2], [2, 5], [2, 4], [1, 3]);
          assert.deepEqual(m._conditions.loc, { $within: { $